---
title: Наблюдатель. Шаблоны проектирования - видео №8. №58. 
subtitle: Текст к видео "#58 Наблюдатель" на канале YouTube
layout: page
show_sidebar: false
menubar: example_menu
author: andrew
category: design_patterns
categories: design_patterns
---

<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/Ft_u9Er9wgE" 
frameborder="0" allow="accelerometer; autoplay; 
encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>

Приветствую на моём канале. Сегодня мы познакомимся с шаблоном проектирования «**Обсерватор**» или «**Наблюдатель**», а также повторим несколько других шаблонов проектирования, 
которые я использовал во время подготовки практического примера: к ним можно отнести «**Декоратор**» и «**Репозиторий**».

![alt text](/assets/images/observator_1.PNG "Схема шаблона Наблюдатель.")

Для начала – несколько слов о сценариях использования. У нас есть объект, состояние которого может измениться, пусть он называется **объект «А»**. Также 
у нас есть другой объект или группа объектов, которые, если можно так сказать, «заинтересованы» в получении информации об изменениях объекта А. Пусть это 
будет один объект, который мы назовём **объект «Б»**. В этом случае если объект «А» изменится, то в объекте «Б» должна быть выполнена определенная логика. Используя 
терминологию паттерна «Наблюдатель», мы можем назвать **объект «Б» наблюдателем**, а **объект «А» - наблюдаемым объектом**. Суть паттерна сводится к тому, чтобы информировать 
наблюдателей об изменениях в наблюдаемых объектах. Я специально использовал здесь множественное число, потому что наблюдателей и наблюдаемых объектов в системе, может 
быть, множество и они могут быть переплетены – один наблюдаемый объект может высылать уведомления нескольким группа наблюдателей, а группы наблюдателей могут наблюдать 
сразу за несколькими наблюдаемыми объектами.

Где на практике мы можем встретить данный шаблон? Например, в интерфейсе пользователя используются списки. Если элементы списка изменятся, мы хотели бы чтобы эти изменения 
были сразу же отображены в списке без явной перезагрузки списка. В этом случае наблюдателем является объект списка, а наблюдаемым объектом является объект коллекции, которая 
содержит элементы списка. Если коллекция изменится, объект списка получит уведомление и также изменит своё состояние, то есть отобразит измененные элементы коллекции. Для 
данной ситуации в .Net уже есть решение. Есть специальный тип **ObservableCollection**, то есть наблюдаемая коллекция, которая при изменении своего состояния отправляет уведомления 
всем заинтересованным объектам. Однако в жизни бывает ситуации более сложные, чем простое изменение коллекции.

Например, в системах промышленной автоматики мы имеем делом с большим количеством датчиков. Это могут быть датчики давления, температуры, напряжения, силы тока, положения и 
состояния объектов, например датчик закрытия / открытия клапана или крана. **Состояния этих датчиков** — **это наблюдаемый объект**, а графический интерфейс оператора определенного 
механизма на фабрике или заводе – это **объект – наблюдатель**. Простейшим примером такого промышленного датчика может быть домашняя метеостанция с табло для отображения 
информации и датчиками температуры на улице и внутри помещения.

При реализации **паттерна «Наблюдатель»** необходимо помнить не только о наблюдателях и наблюдаемых объектах, но и о том, как наблюдатели будут связаны с наблюдаемыми объектами. 
В примере, который мы сегодня рассмотрим, каждый наблюдаемый объект будет иметь коллекцию наблюдателей, которым будут отправлять определенные уведомления. Каждый наблюдатель 
может зарегистрироваться у наблюдателя для получения уведомлений об изменении состояния наблюдаемого объекта.

То есть для начала работы нам будет необходима регистрация наблюдателей. Далее приложение будет нормально работать и отправлять уведомления. Для примера в конце работы 
приложения мы отпишем наблюдателей от наблюдаемых объектов. Естественно, отписка может происходить и в процессе работы приложения в зависимости от определённых условий 
бизнес – логики.

![alt text](/assets/images/observator_2.PNG "Регистрация наблюдателей в шаблоне Наблюдатель.")

Конкретно в нашем практическом примере мы будем иметь дело с почтовым ящиком. Пользователе нашего приложения имеют возможность отправлять друг другу сообщения: так как 
это происходит в социальных сетях. Когда сообщение отправлено мы отправляем уведомление о том, что такая ситуация имела место. Итого, почтовый ящик — это наш наблюдаемый 
объект. В качестве наблюдателей у нас будут 3 объекта: сервис для отправки смс сообщений, сервис для отправки электронной почты, сервис для отображений уведомлений на 
интерфейсе пользователя. Однако сервис для отображения уведомлений на интерфейсе пользователя будет обрабатывать уведомление, только если пользователь есть онлайн.

![alt text](/assets/images/observator_3.PNG "Схема работы приложения - практического прмиера с шаблоном Наблюдатель.")

Давайте посмотрим на код и запустим наш пример.

Сегодня мы познакомились с шаблоном проектирования «Обсерватор / Наблюдатель». По сути то, что было показано сегодня это только лишь определенная вариация на данную тему. 
В видео посвященному **микроуслугам** я упомянул шины сообщений – это также в своем роде является имплементацией паттерна проектирования «Обсерватор / Наблюдатель». 
<a href ="https://youtu.be/4Z7zoF1w3KY" target="_blank">Ссылка на данное видео</a> будет в верхнем правом углу и в описании к данному видео. Также вы, возможно, слышали 
о шаблоне **EventAggregator**, который также является реализаций паттерна 
«Обсерватор / Наблюдатель».

Надеюсь, данное видео было вам интересно и то, что вы узнали сегодня вы сможете использовать на практике в проектах, над которыми вы работаете. Буду благодарен за помощь 
в продвижении канала – за лайк, подписку и положительный комментарий. Благодарю вас за внимание и до новых встреч.

<a href ="https://github.com/ashyrokoriadov/DesignPatterns" target="_blank">Пример кода из видео на GitHub</a><br/>

Для открытия файла проекта необходимо Visual Studio 2019.
